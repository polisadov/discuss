{"version":3,"sources":["socket.js"],"names":[],"mappings":"AAAA;AACA;;AAEA;AACA;AACA,SAAQ,MAAR,QAAqB,SAArB;;AAEA,IAAI,SAAS,IAAI,MAAJ,CAAW,SAAX,EAAsB,EAAC,QAAQ,EAAC,OAAO,OAAO,SAAf,EAAT,EAAtB,CAAb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,OAAP;;AAEA,MAAM,eAAgB,OAAD,IAAa;AAC9B,QAAI,UAAU,OAAO,OAAP,CAAgB,YAAW,OAAQ,EAAnC,EAAsC,EAAtC,CAAd;AACA,YAAQ,IAAR,GACK,OADL,CACa,IADb,EACmB,QAAQ;AACnB,uBAAe,KAAK,QAApB;AACH,KAHL,EAIK,OAJL,CAIa,OAJb,EAIsB,QAAQ;AACtB,gBAAQ,GAAR,CAAY,gBAAZ,EAA8B,IAA9B;AACH,KANL;;AAQA,aAAS,aAAT,CAAuB,QAAvB,EAAiC,gBAAjC,CAAkD,OAAlD,EAA2D,MAAM;AAC7D,cAAM,UAAU,SAAS,aAAT,CAAuB,UAAvB,EAAmC,KAAnD;;AAEA,gBAAQ,IAAR,CAAa,aAAb,EAA4B,EAAC,SAAS,OAAV,EAA5B;AACH,KAJD;AAKH,CAfD;;AAiBA,SAAS,cAAT,CAAwB,QAAxB,EAAkC;AAC9B,UAAM,mBAAmB,SAAS,GAAT,CAAa,WAAW;AAC9C,eAAQ;;kBAEG,QAAQ,OAAQ;;aAF3B;AAKF,KANwB,CAAzB;;AAQA,aAAS,aAAT,CAAuB,aAAvB,EAAsC,SAAtC,GAAkD,iBAAiB,IAAjB,CAAsB,EAAtB,CAAlD;AAEH;;AAED,OAAO,YAAP,GAAsB,YAAtB","file":"socket-compiled.js","sourcesContent":["// NOTE: The contents of this file will only be executed if\n// you uncomment its entry in \"web/static/js/app.js\".\n\n// To use Phoenix channels, the first step is to import Socket\n// and connect at the socket path in \"lib/my_app/endpoint.ex\":\nimport {Socket} from \"phoenix\"\n\nlet socket = new Socket(\"/socket\", {params: {token: window.userToken}})\n\n// When you connect, you'll often need to authenticate the client.\n// For example, imagine you have an authentication plug, `MyAuth`,\n// which authenticates the session and assigns a `:current_user`.\n// If the current user exists you can assign the user's token in\n// the connection for use in the layout.\n//\n// In your \"web/router.ex\":\n//\n//     pipeline :browser do\n//       ...\n//       plug MyAuth\n//       plug :put_user_token\n//     end\n//\n//     defp put_user_token(conn, _) do\n//       if current_user = conn.assigns[:current_user] do\n//         token = Phoenix.Token.sign(conn, \"user socket\", current_user.id)\n//         assign(conn, :user_token, token)\n//       else\n//         conn\n//       end\n//     end\n//\n// Now you need to pass this token to JavaScript. You can do so\n// inside a script tag in \"web/templates/layout/app.html.eex\":\n//\n//     <script>window.userToken = \"<%= assigns[:user_token] %>\";</script>\n//\n// You will need to verify the user token in the \"connect/2\" function\n// in \"web/channels/user_socket.ex\":\n//\n//     def connect(%{\"token\" => token}, socket) do\n//       # max_age: 1209600 is equivalent to two weeks in seconds\n//       case Phoenix.Token.verify(socket, \"user socket\", token, max_age: 1209600) do\n//         {:ok, user_id} ->\n//           {:ok, assign(socket, :user, user_id)}\n//         {:error, reason} ->\n//           :error\n//       end\n//     end\n//\n// Finally, pass the token to the Socket constructor as above.\n// Or, remove it from the constructor if you don't care about\n// authentication.\n\nsocket.connect()\n\nconst createSocket = (topicId) => {\n    let channel = socket.channel(`comments:${topicId}`, {})\n    channel.join()\n        .receive(\"ok\", resp => {\n            renderComments(resp.comments);\n        })\n        .receive(\"error\", resp => {\n            console.log(\"Unable to join\", resp)\n        })\n\n    document.querySelector('button').addEventListener('click', () => {\n        const content = document.querySelector('textarea').value\n\n        channel.push('comment:add', {content: content})\n    });\n}\n\nfunction renderComments(comments) {\n    const renderedComments = comments.map(comment => {\n       return `\n            <li class=\"collection-item\">\n                ${comment.content}\n            </li>\n            `;\n    });\n\n    document.querySelector('.collection').innerHTML = renderedComments.join('');\n\n}\n\nwindow.createSocket = createSocket;\n"]}